#include <iostream> // подключаем библиотеку для ввода-вывода
#include <vector> // подключаем библиотеку для работы с динамическими массивами
#include <omp.h> // подключаем библиотеку openmp для многопоточности на cpu
#include <chrono> // подключаем библиотеку для замера времени выполнения

int main() {
    // задаем размер массива - миллион элементов
    const int N = 1000000;
    
    // создаем вектор (динамический массив) и заполняем его значениями от 0 до 999999
    std::vector<float> data(N);
    for (int i = 0; i < N; i++) {
        data[i] = i; // каждый элемент равен своему индексу
    }
    
    // запоминаем время начала обработки
    auto start = std::chrono::high_resolution_clock::now();
    
    // используем openmp для параллельной обработки массива
    #pragma omp parallel for // эта директива говорит компилятору распараллелить следующий цикл
    for (int i = 0; i < N; i++) {
        data[i] = data[i] * 2; // умножаем каждый элемент массива на 2
    }
    
    // запоминаем время окончания обработки
    auto end = std::chrono::high_resolution_clock::now();
    
    // вычисляем разницу во времени и переводим в миллисекунды
    std::chrono::duration<double, std::milli> duration = end - start;
    
    // выводим результаты на экран
    std::cout << "обработка на cpu (openmp):" << std::endl;
    std::cout << "размер массива: " << N << std::endl;
    std::cout << "время выполнения: " << duration.count() << " мс" << std::endl;
    
    // выводим несколько первых элементов для проверки корректности
    std::cout << "первые 5 элементов после обработки: ";
    for (int i = 0; i < 5; i++) {
        std::cout << data[i] << " "; // элементы должны быть 0, 2, 4, 6, 8
    }
    std::cout << std::endl;
    
    return 0; // завершаем программу
}
