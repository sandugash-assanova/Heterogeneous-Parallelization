// lab3.cpp                           // имя файла
// динамический массив + указатели + параллельный подсчёт среднего // краткое описание программы

#include <iostream>                  // ввод и вывод
#include <random>                    // генерация случайных чисел
#include <chrono>                    // измерение времени
#include <omp.h>                     // функции openmp

using namespace std;                 // чтобы не писать std::

int main() {                          // точка входа в программу
    // ------------------------       // визуальный разделитель
    // настройки                      // блок настроек
    // ------------------------       // визуальный разделитель
    size_t N;                         // размер массива
    cout << "Enter size of array N: "; // запрос размера массива
    cin >> N;                         // ввод размера массива
    if (N == 0) {                     // проверка на нулевой размер
        cerr << "Array size must be > 0\n"; // сообщение об ошибке
        return 1;                     // аварийный выход
    }

    constexpr int RAND_MIN_VAL = 1;   // минимальное случайное значение
    constexpr int RAND_MAX_VAL = 100; // максимальное случайное значение

    // ------------------------       // визуальный разделитель
    // динамический массив            // блок работы с массивом
    // ------------------------       // визуальный разделитель
    int* arr = new int[N];            // выделение памяти под массив

    random_device rd;                 // источник энтропии
    mt19937 gen(rd());                // генератор случайных чисел
    uniform_int_distribution<int> dist(RAND_MIN_VAL, RAND_MAX_VAL); // диапазон значений

    for (size_t i = 0; i < N; ++i) {  // цикл заполнения массива
        arr[i] = dist(gen);           // генерация случайного числа
    }

    if (N <= 50) {                    // если массив маленький
        cout << "Array: ";            // вывод заголовка
        for (size_t i = 0; i < N; ++i) cout << arr[i] << " "; // вывод элементов
        cout << "\n";                 // перевод строки
    } else {                          // если массив большой
        cout << "Array size " << N << " (not printed)\n"; // вывод размера
    }

    // ------------------------       // визуальный разделитель
    // последовательное вычисление среднего // sequential версия
    // ------------------------       // визуальный разделитель
    auto t1 = chrono::high_resolution_clock::now(); // старт таймера
    double sum_seq = 0.0;             // сумма элементов
    for (size_t i = 0; i < N; ++i) sum_seq += arr[i]; // суммирование
    double avg_seq = sum_seq / N;     // вычисление среднего
    auto t2 = chrono::high_resolution_clock::now(); // конец таймера
    chrono::duration<double, milli> dur_seq = t2 - t1; // время выполнения

    // ------------------------       // визуальный разделитель
    // параллельное вычисление среднего с openmp // parallel версия
    // ------------------------       // визуальный разделитель
    double avg_par = 0.0;             // среднее для параллельной версии
    auto t3 = chrono::high_resolution_clock::now(); // старт таймера
#ifdef _OPENMP                       // если openmp доступен
    double sum_par = 0.0;             // сумма для параллельного расчёта
    #pragma omp parallel for reduction(+:sum_par) // параллельный цикл с редукцией
    for (size_t i = 0; i < N; ++i) {  // параллельный цикл
        sum_par += arr[i];            // добавление элемента
    }
    avg_par = sum_par / N;            // вычисление среднего
#else                                // если openmp недоступен
    avg_par = avg_seq;                // используем последовательный результат
#endif                               // конец проверки openmp
    auto t4 = chrono::high_resolution_clock::now(); // конец таймера
    chrono::duration<double, milli> dur_par = t4 - t3; // время выполнения

    // ------------------------       // визуальный разделитель
    // вывод результатов              // блок вывода
    // ------------------------       // визуальный разделитель
    cout << "\nSEQUENTIAL: Average = " << avg_seq << ", time = " << dur_seq.count() << " ms\n"; // вывод sequential
    cout << "PARALLEL:   Average = " << avg_par << ", time = " << dur_par.count() << " ms\n";   // вывод parallel

#ifdef _OPENMP                       // если openmp доступен
    cout << "OpenMP threads: " << omp_get_max_threads() << "\n"; // вывод числа потоков
#endif                               // конец проверки openmp

    // ------------------------       // визуальный разделитель
    // освобождение памяти            // очистка ресурсов
    // ------------------------       // визуальный разделитель
    delete[] arr;                     // освобождение массива
    arr = nullptr;                    // защита от висячего указателя

    return 0;                         // успешное завершение программы
}
